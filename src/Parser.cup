import java_cup.runtime.*;

parser code  {:
  public boolean syntaxErrors = false;
  public void syntax_error(Symbol current_token) {
    report_error(
    "Syntax error at line " + (current_token.left + 1) + ", column "
    + current_token.right, null
    );
    syntaxErrors = true;
  }
:};

// *************************************
// ===== TERMINALS & NON-TERMINALS =====
// *************************************

// Control flow
terminal IF, THEN, ELSE, ENDIF;
terminal LOOP, ENDLOOP;
terminal BREAK;
terminal RETURN;

// Entry point
terminal MAIN;

// Type definitions
terminal DEFINE_FUNCTION; // fdef
terminal DEFINE_TYPE;     // tdef
terminal ALIAS;

// Primitive types
terminal BOOLEAN;         // Boolean type
terminal CHAR;            // Character type (single)
terminal INT, RAT, FLOAT; // Numeric types
terminal SEQ;             // List type
terminal DICT;            // Dictionary type

// Input / output
terminal READ;
terminal PRINT;

// Separators
terminal LPAREN, RPAREN; // ()
terminal LBRACE, RBRACE; // {}
terminal LBRACK, RBRACK; // []
terminal LANGLE, RANGLE; // <>

terminal SEMICOLON;
terminal COLON;
terminal COMMA;
terminal DOT;

/* OPERATORS */

// Boolean operators
terminal NOT;      // !
terminal AND;      // &&
terminal OR;       // ||
terminal IMPLIES;  // =>

// Numeric operators
terminal PLUS, MINUS, MULT, DIV, POF; // +, -, *, /, ^
terminal EQEQ, LTEQ;                  // =, <= (comparison)

// Language constructs
terminal EQ;                          // := (assignment)
terminal IN;                          // 'in' - Dictionary and seq in
terminal CONCAT;                      // :: (concat for dictionaries)
terminal QUESTION;                    // ? (surrounds predicate for function calls)

// Literals
terminal java.lang.Number    INTEGER_LITERAL;
terminal java.lang.Number    FLOAT_LITERAL;
terminal java.lang.Boolean   BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String    STRING_LITERAL;

terminal                     NULL_LITERAL;
terminal                     RATIONAL_LITERAL;

terminal java.lang.String    IDENTIFIER;



/* non-terminals */
// The Syntactic Grammar
nonterminal goal;
// Lexical Structure
nonterminal literal;

// Types, values and variables
nonterminal type, primitive_type, numeric_type;                 
nonterminal integral_type, floating_point_type, rational_type;    
nonterminal reference_type;
nonterminal sequence_type;
nonterminal struct_type;
nonterminal dict_type;

// Names
nonterminal name, simple_name, qualified_name; 

// Variable Declerations
nonterminal variable_declaration;
nonterminal variable_declarator;
nonterminal variable_declarator_id, variable_initializer;

// Sequence
nonterminal sequence_initializer;

// Method Declarations
nonterminal method_type_opt, method_type; // Optional type for fdef
nonterminal method_declaration, method_header, method_declarator;
nonterminal formal_parameter_list_opt, formal_parameter_list;
nonterminal formal_parameter;
nonterminal method_body;

// Structure Declarations
nonterminal struct_declaration;
nonterminal struct_body;
nonterminal struct_body_declarations_opt, struct_body_declaration_opt;
nonterminal struct_declarations_opt, struct_declarations;
nonterminal struct_body_declaration, struct_body_declarations, struct_member_declaration;

// Dictionary Declarations
nonterminal field_declaration;
nonterminal key_val_pairs_opt;
nonterminal key_val_pairs, key_val_pair;
// Block
nonterminal block;
nonterminal block_statements_opt;
nonterminal block_statements, block_statement;
nonterminal return_statement;
// Expressions
nonterminal expression;
nonterminal unary_expression;

nonterminal seq_initializer;
nonterminal dict_initializer;
nonterminal key_value_pairs_opt;
nonterminal key_value_pairs;
nonterminal key_value_pair;
nonterminal elements_opt;
nonterminal elements;
nonterminal element;


// *************************************
// ========= Production rules ==========
// *************************************

// 1.0 Literals
literal ::= 
    INTEGER_LITERAL
  | FLOAT_LITERAL
  | BOOLEAN_LITERAL
  | RATIONAL_LITERAL
  | CHARACTER_LITERAL
  | STRING_LITERAL;

// 2.0) Types, values and variables  
type ::= primitive_type
  | reference_type;

primitive_type ::= numeric_type
  | BOOLEAN;

numeric_type::= integral_type
  | floating_point_type
  | rational_type;

integral_type ::= INT 
  | CHAR;

floating_point_type ::= FLOAT;

rational_type ::= RAT;

reference_type ::= sequence_type
  | struct_type
  | dict_type;

sequence_type ::= SEQ LANGLE primitive_type RANGLE;
struct_type ::= DEFINE_TYPE;
dict_type ::= DICT LANGLE type COMMA type RANGLE;



// 3.0) Names
name ::= simple_name
  | qualified_name;

simple_name ::= IDENTIFIER;
qualified_name ::= name DOT IDENTIFIER;


// 4.0) Field Declerations Defition
variable_declaration ::= IDENTIFIER COLON type EQ variable_initializer SEMICOLON;

variable_initializer ::= expression 
  | seq_initializer 
  | dict_initializer; 


// 5.0) Method Decleration Definition
method_declaration ::= method_header method_body method_type_opt SEMICOLON;

method_type_opt ::= 
  | method_type;

method_type ::= COLON type;

method_header ::= DEFINE_FUNCTION method_declarator
  | MAIN;

method_declarator ::= IDENTIFIER LPAREN formal_parameter_list_opt RPAREN
  | LPAREN formal_parameter_list_opt RPAREN;

formal_parameter_list_opt ::=
  | formal_parameter_list;

formal_parameter_list ::= formal_parameter
  | formal_parameter_list COMMA formal_parameter;

formal_parameter ::= IDENTIFIER COLON type;

// TODO :: STATEMENTS 
method_body ::= block 
  | SEMICOLON;


// 6.0) Structure 
struct_declaration ::= DEFINE_TYPE IDENTIFIER struct_body SEMICOLON;

struct_body ::= LBRACE struct_body_declarations_opt RBRACE;

struct_body_declaration_opt ::=
  | struct_body_declarations;

struct_body_declarations ::= struct_body_declaration
  | struct_body_declarations COMMA struct_body_declaration;

struct_body_declaration ::= IDENTIFIER COLON type
  | IDENTIFIER COLON IDENTIFIER;


// TODO: 
// ALIAS - etc. alias seq<char> string;

// 7.0) Dictionary
dict_initializer ::= LBRACE key_value_pairs_opt RBRACE;

key_value_pairs_opt ::=
  | key_value_pairs;

key_value_pairs ::= key_value_pair
  | key_value_pairs COMMA key_value_pair;

key_value_pair ::= literal COLON literal;


// 8.0) Sequence
seq_initializer ::= LBRACK elements_opt RBRACK;

elements_opt ::=
  | elements;

elements ::= element
  | elements COMMA element;

// Blocks and Statements
block ::= LBRACE block_statements_opt RBRACE;

block_statements_opt ::= 
  | block_statements;

block_statements ::= block_statement
  | block_statements block_statement;

block_statement ::= struct_declaration
  | return_statement;
  
return_statement ::= RETURN SEMICOLON;




